<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>16.面向服务的架构 - P3的Blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="p3p3pp3"><meta name=description content="原文：https://herbertograca.com/2017/11/09/service-oriented-architecture-"><meta name=keywords content="P3,blog,coding"><meta name=baidu-site-verification content="code-rMlGvJbrZW"><meta name=google-site-verification content="iTJj3dp57yfylJL_-Z2_nwxz5Dz6jnf1xAwgKb6TS_g"><meta name=generator content="Hugo 0.109.0 with theme even"><link rel=canonical href=https://p3p3pp3.github.io/post/2021/software-architecture/16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.html><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="16.面向服务的架构"><meta property="og:description" content="原文：https://herbertograca.com/2017/11/09/service-oriented-architecture-"><meta property="og:type" content="article"><meta property="og:url" content="https://p3p3pp3.github.io/post/2021/software-architecture/16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-05-16T14:01:26+08:00"><meta property="article:modified_time" content="2021-05-16T14:01:26+08:00"><meta itemprop=name content="16.面向服务的架构"><meta itemprop=description content="原文：https://herbertograca.com/2017/11/09/service-oriented-architecture-"><meta itemprop=datePublished content="2021-05-16T14:01:26+08:00"><meta itemprop=dateModified content="2021-05-16T14:01:26+08:00"><meta itemprop=wordCount content="6553"><meta itemprop=keywords content="architecture,SOA,"><meta name=twitter:card content="summary"><meta name=twitter:title content="16.面向服务的架构"><meta name=twitter:description content="原文：https://herbertograca.com/2017/11/09/service-oriented-architecture-"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P3的Blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post.html><li class=mobile-menu-item>Archives</li></a><a href=/tags.html><li class=mobile-menu-item>Tags</li></a><a href=/categories.html><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P3的Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post.html>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags.html>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories.html>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>16.面向服务的架构</h1><div class=post-meta><span class=post-time>2021-05-16</span>
<span class=more-meta>约 6553 字</span>
<span class=more-meta>预计阅读 14 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#corbacommon-object-request-broker-architecture通用对象请求代理架构>CORBA(Common Object Request Broker Architecture，通用对象请求代理架构)</a><ul><li><a href=#工作原理>工作原理</a></li><li><a href=#优点>优点</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#web-服务><strong>Web 服务</strong></a><ul><li><a href=#优点-1>优点</a></li><li><a href=#缺点-1>缺点</a></li></ul></li><li><a href=#消息队列><strong>消息队列</strong></a><ul><li><a href=#优点-2>优点</a></li><li><a href=#缺点-2>缺点</a></li></ul></li><li><a href=#企业服务总线esbenterprise-service-bus>企业服务总线（ESB，Enterprise Service Bus）</a><ul><li><a href=#优点-3>优点</a></li><li><a href=#缺点-3>缺点</a></li></ul></li><li><a href=#微服务>微服务</a><ul><li><a href=#优点-4>优点</a></li><li><a href=#缺点-4>缺点</a></li></ul></li><li><a href=#反模式意式馄饨架构>反模式：意式馄饨架构</a></li><li><a href=#总结>总结</a></li><li><a href=#引用来源>引用来源</a></li></ul></nav></div></div><div class=post-content><p>原文：https://herbertograca.com/2017/11/09/service-oriented-architecture-soa/</p><p><em>这篇文章是
<a href=https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/ target=_blank>软件架构编年史</a>(
<a href=https://www.jianshu.com/p/b477b2cc6cfa target=_blank>译</a>)的一部分，这部编年史由
<a href=https://herbertograca.com/category/development/series/software-architecture/ target=_blank>一系列关于软件架构的文章</a>组成。在这一系列文章中，我将写下我对软件架构的学习和思考，以及我是如何运用这些知识的。如果你阅读了这个系列中之前的文章，本篇文章的的内容将更有意义。</em></p><p>SOA 风格在 20 世纪 80 年代末就已出现，它起源于 CORBA、DCOM、DCE 和其它一些概念。关于 SOA 的讨论太多了，也有一些不同的实现模式，但从本质上讲，SOA 并没有给出如何实现它们的处方，而是仅仅聚焦于一些概念：</p><ul><li>面向用户的应用的可组合性；</li><li>可重用的业务服务；</li><li>独立技术栈；</li><li>自治(独立演进、可扩展和可部署) 。</li></ul><p>SOA 是一组和技术或产品无关的架构原则，这和多态以及封装一样。</p><p>在这篇文章里，我将探讨下面这些和 SOA 相关的模式：</p><ul><li>CORBA – Common Object Request Broker Architecture</li><li>Web 服务</li><li>消息队列</li><li>企业服务总线</li><li>微服务</li></ul><h1 id=corbacommon-object-request-broker-architecture通用对象请求代理架构>CORBA(Common Object Request Broker Architecture，通用对象请求代理架构)</h1><p>在 20 世纪 80 年代，随着企业网络和 C/S 架构应用的增长，对使用不同技术构建并且运行在不同地电脑和操作系统上的应用之间的通用通信方法的需求也越来越迫切。CORBA 因此诞生。它是一个分布式计算标准，20 世纪 80 年代发展起来并于 1991 年发布了第一个成熟版本。</p><p>CORBA 标准由多家供应商实现，其目标是提供：</p><ul><li>平台中立的远程过程调用；</li><li>事务(还有远程事务)；</li><li>安全性；</li><li>事件；</li><li>编程语言无关；</li><li>操作系统无关；</li><li>硬件无关；</li><li>数据转换和通信细节分离；</li><li>接口定义语言(IDL)实现数据类型。</li></ul><p>现在 CORBA 依然在异构计算中发挥余热，例如，
<a href=http://docs.oracle.com/javase/7/docs/technotes/guides/idl/corba.html target=_blank>它依然是 JAVA EE</a>的一部分，尽管
<a href=https://www.infoq.com/news/2016/06/corba-removed-java-9 target=_blank>从 JAVA 9 开始它会被作为一个独立的模块打包</a>。</p><p>有一点要说明，<strong>我并不认为 CORBA 是一种 SOA 模式</strong>(虽然我认为 CORBA 和 SOA 模式都属于分布式计算范畴)。这里之所以要介绍它，是因为我觉得是<strong>它的短板导致了 SOA</strong> 运动。</p><h2 id=工作原理>工作原理</h2><p>首先，我们需要获取一个对象请求代理(ORB，Object Request Broker)，它由供应商提供，符合 CORBA 规范，使用语言映射器生成用客户端代码语言表示的桩和骨架。使用 ORB 和 IDL (和 WSDL 类似)定义的接口定义，在客户端生成与可以远程调用真正类的<strong>桩</strong>类，在服务器生成可以处理收到的请求并调用真正目标对象的<strong>骨架</strong>。</p><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-03e2c6add2debf08.png alt=img></p><ol><li>调用者调用通过桩实现的本地过程；</li><li>桩验证调用并创建一个请求消息传给 ORB；</li><li>客户端 ORB 通过网络把消息传给服务器并阻塞当前的执行线程；</li><li>服务器 ORB 收到请求消息并实例化骨架；</li><li>骨架执行被调用对象的过程；</li><li>被调用对象执行计算并返回结果；</li><li>骨架将输出参数压缩成一个响应消息并传给 ORB；</li><li>ORB 将消息通过网络发回客户端；</li><li>客户端 ORM 收到响应消息，展开并发给桩；</li><li>桩将输出参数传给调用者，释放执行线程，然后调用者继续执行。</li></ol><h2 id=优点>优点</h2><ul><li>技术栈无关(除了 ORB 的实现之外)；</li><li>数据转换和通信细节分离。</li></ul><h2 id=缺点>缺点</h2><ul><li><strong>地点透明</strong>：客户端代码不知道调用到底是本地的还是远程的。这听起来不错，然而，两者的时延和错误种类大相径庭。如果不知道调用的类型，应用就不可能选择合适的策略来处理方法调用，最后可能错误地将远程调用放到循环里，导致整个系统性能明显下降。</li><li><strong>复杂、冗余、充满歧义的规范</strong>：它拥一些现有的供应商版本堆砌而成，容易引起歧义，而且多余，实现起来非常困难。</li><li><strong>通信管道被拦截</strong>：它使用了基于 TCP/IP 的特定协议和特定端口，甚至是随机的端口。但企业安全规则和防火墙通常只允许 80 端口的 HTTP 协议，实际种会拦截 CORBA 通信。</li></ul><h1 id=web-服务><strong>Web 服务</strong></h1><p>尽管 CORBA 现在仍然有使用场景，但我们也学到了一些经验：<strong>需要减少远程通信</strong>来提升系统性能，<strong>通信管道必须可靠</strong>，<strong>通信规范必须简化</strong>。</p><p>因此，在 20 世纪 90 年代末，Web 服务得到了大量应用，其目标是解决下面这些问题：</p><ul><li><strong>通信管道必须可靠</strong>，所以：<ul><li><strong>80 端口的 HTTP</strong> 是默认的通信管道；</li><li>使用<strong>通用的通信语言</strong>(比如 <strong>XML</strong> 和 <strong>JSON</strong>) ；</li></ul></li><li><strong>需要减少远程通信</strong>，所以：<ul><li>有了<strong>显式远程通信</strong>，这样就能确切地知道何时发起了远程调用；</li><li>有了<strong>粗粒度的远程调用</strong>，例如，不用再频繁调用远程对象，少量调用远程服务即可；</li></ul></li><li><strong>通信规范必须简化</strong>，所以：<ul><li>1998 年<strong>SOAP</strong> 发布了第一版草案，在 2003 年获得了 W3C 推荐，成为了事实上的标准。它体现了一些 CORBA 的思想，例如一个用于处理通信的层次和使用 <em>Web 服务描述语言</em> (WSDL，Web Services Description Language)定义的“文档”；</li><li>Roy Fielding 于 2000 年在他的论文 “<em>Architectural Styles and the Design of Network-based Software Architectures</em>”中定义了 <strong>REST</strong>，它是比 SOAP 简单得多，迅速得到推广，比稍早诞生的 SOAP 规范应用得更广。</li><li>Facebook 于 2012 年开发了 <strong>GraphQL</strong> 并在 2015 年开源。它是一种 API 查询语言，允许客户端准确地指定服务端应该返回什么数据，而不是专用的负载格式，来避免数据的过度抓取和不足抓取。</li></ul></li></ul><blockquote><p>[Web] 服务能够以一种技术中立、标准的形式被发布、发现和使用。<br>—— Microsoft 2004,
<a href=https://msdn.microsoft.com/en-us/library/aa480021.aspx target=_blank>Understanding Service-Oriented Architecture</a></p></blockquote><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-c44dc90d096dab29.png alt=img></p><p>通过 Web 服务，SOA 完成了从远程调用对象方法的范式（CORBA），到在服务之间传递消息的范式转换。</p><p>我们要明白，尽管 Web 服务属于 SOA 范畴，但一个 Web 服务并不只是一个通过 HTTP 简单地提供数据库 CRUD 访问的通用 API。也许这种实现有些情况下有用，<em>它要求用户理解底层模型并遵循业务规则来确保数据完整性得到保护</em>。SOA 意味着 Web 服务应该设计成业务子域的限界上下文，从它们提供的概念服务中抽象出实现。</p><blockquote><p>从技术角度看，SOA 不仅仅是服务的架构，还是确保提供和使用正确服务的策略、实现和框架。<br>—— Microsoft 2004,
<a href=https://msdn.microsoft.com/en-us/library/aa480021.aspx target=_blank>Understanding Service-Oriented Architecture</a></p></blockquote><h2 id=优点-1>优点</h2><ul><li>服务与技术栈无关，服务可以独立部署和扩展；</li><li><strong>通用、简单以及可靠的通信通道(通过 HTTP 80 端口的文本)</strong>；</li><li><strong>最优的通信</strong>；</li><li><strong>稳定的通信标准</strong>；</li><li><strong>领域上下文隔离</strong>。</li></ul><h2 id=缺点-1>缺点</h2><ul><li>不同的 Web 服务<strong>集成困难</strong>，这是不同的通信语言造成的，例如，两个 Web 服务使用不同的 JSON 表示同一个概念；</li><li>同步通信可能让系统<strong>过载</strong>。</li></ul><h1 id=消息队列><strong>消息队列</strong></h1><p>其核心思想是让应用之间使用语言无关的消息进行异步通信。消息队列提升了应用的可扩展性，降低了应用之间的耦合，因为不用知道其它应用部署在哪里、部署了多少，甚至都不用知道它们是什么。除此之外，它们全部需要使用同样的通信语言，例如，提前定义好的可以表示数据的文本格式。</p><p>消息队列使用消息代理软件（例如，RabbitMQ、Beanstalkd、Kafka 等）作为基础设施，可以y用不同地方式设置，实现应用间通信：</p><ul><li><strong>请求/回复</strong><ul><li>客户端将消息发送给消息队列，包括“<em>对话</em>”的引用。消息被投递给特定节点，该节点回复另一条消息给原来的发送者。这条消息包含同样的<em>对话</em>引用，这样接收者才知道它和哪次<em>对话</em>有关，流程才可以继续下去。对于中等时间和长时间的业务进程（<strong>sagas</strong>）来说，这很有用。</li></ul></li><li><strong>发布/订阅</strong><ul><li><strong>基于列表</strong>
它维护着发布主题列表和这些主题的订阅者。当收到某个主题的消息后，将消息放到对应主题列表中。消息和主题的匹配可以通过消息类型或者一组事先定义的更复杂的条件完成，这些条件和消息内容有关。</li><li><strong>基于广播</strong>
当它收到消息后，将消息广播给所有监听该队列的节点。每个监听节点负责过滤和处理自己感兴趣的消息。</li></ul></li></ul><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-1fa7fde3eedd9c9d.jpg alt=img></p><p>所有这些模式都可以设置成<strong>拉取</strong>（又叫做<em>轮询</em>）或者<strong>推送</strong>方式：</p><ul><li><strong>拉取场景</strong>下，客户端每隔一段时间 <em>X</em>，就从队列中取一条消息。这样做的优势是<strong>客户端可以控制它的负载</strong>，却<strong>会产生延迟</strong>的劣势 。例如，消息已经到达队列中，客户端却并不会马上处理消息而是在等待轮询消息的时刻到来；</li><li><strong>推送场景</strong>下，队列一收到消息就会推送给客户端。这样就<strong>没有延迟</strong>，但<strong>客户端不能自己控制负载</strong>。</li></ul><h2 id=优点-2>优点</h2><ul><li>服务与技术栈无关，服务可以独立部署和扩展；</li><li>通用、简单以及可靠的通信通道(通过 HTTP 80 端口的文本)；</li><li>最优的通信；</li><li>稳定的通信标准；</li><li>领域上下文隔离；</li><li><strong>服务可以轻松地连接和断开</strong>；</li><li><strong>通过异步通信控制系统负载</strong>。</li></ul><h2 id=缺点-2>缺点</h2><ul><li>不同的 Web 服务<strong>集成困难</strong>，这是不同的通信语言造成的，例如，两个 Web 服务使用不同的 JSON 表示同一个概念；</li></ul><h1 id=企业服务总线esbenterprise-service-bus>企业服务总线（ESB，Enterprise Service Bus）</h1><p>上世纪 90 年代，在 Web 服务蓬勃发展的同时，企业服务总线已经在应用它们了（可能有些实现最初甚至使用了 CORBA？）。</p><p>ESB 诞生于这样一种环境下：公司拥有一些独立的应用，比如财务应用、人力资源应用、股票管理应用等等，这些应用需要互相通信，需要集成。但这些应用没有考虑过集成，它们没有应用通信所需的通用语言格式（直到现在也没有这样一种格式）。因此，合理的解决方案是由应用提供商创建发送和接收特定格式数据的终端节点。然后，客户公司必须建立通信管道来集成应用，并将一种应用语言的消息转换成另一种。</p><p>消息队列可能有助于解决这个问题，但无法解决应用各自拥有不同语言格式的难题。不过，消息队列从哑通信通道变成了中间件，它既可以处理消息投递，也可以将消息转换成接收端期望的语言/格式，这前进了一小步。相对简单的消息队列自然演进的结果就是 ESB。</p><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-f3e53579be9a49fb.gif alt=img></p><p>这种架构类型一版会有典型的面向用户的复合应用，它们联系 Web 服务来执行某个操作。而这些 Web 服务接下来也会联系其它 Web 服务并最终返回一些数据给复合应用。然而复组合应用和后端服务互相都不知道对方的具体细节，即它们的位置和通信协议。它们知道的只是需要哪些服务和服务总线的位置。</p><p>这样，客户应用（服务也好，复合应用也罢）将请求发送给服务总线，然后由总线将消息转换成目的地期望的格式并将请求<strong>路由</strong>到目的地。需要注意的是，<strong>所有</strong>的通信同要经过 ESB，也就是说一旦 ESB 宕机，所有通信也会宕机，所有系统也会无法运行。最后，ESB 就像一个中间件那样工作，其中发生的事情太多太多，最后呈现的是一个相当复杂的构件。</p><p>当然，这只是对 ESB 架构的非常浅显的解释。此外，尽管 ESB 是这种架构中主要的构件，还有其他一些构件也会被涉及，比如域代理、数据服务、流程编排服务或规则引擎。在系统按照业务领域隔离的联合设计中也可以应用同样的架构风格，每个领域都有自己的 ESB设置，所有这些设置会将它们连接起来。这有助于提升性能和缓解单点故障的问题，例如，一个 ESB 的故障只会影响它所属的那个业务领域。</p><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-5f040b2b0ebdd049.jpg alt=img></p><p>ESB 的主要职责是：</p><ul><li>监控和控制服务之间交换消息的<strong>路由</strong>；</li><li>解决互相通信的服务组件之间的<strong>消息转换</strong>；</li><li>控制服务的<strong>部署</strong>和<strong>版本</strong>；</li><li>提供事件处理、数据转换和映射、消息和事件排队以及排序、安全或异常处理、协议转换等日常服务，保障通信服务的质量;</li></ul><blockquote><p>对于在不同的进程之间各种通信结构的构建，我们已经看到许多产品和方法，强调在通信机制本身大做文章。企业服务总线（ESB）就是一个很好的例子。ESB 产品经常包含复杂的设施，来进行消息的路由、编排、转换以及业务规则的应用。—— Martin Fowler 2014,
<a href=https://martinfowler.com/articles/microservices.html target=_blank>Microservices</a></p></blockquote><p>这种架构模式有其优势，特别是在下面这样种情况下尤其有用。这种情况下，我们没有 Web 服务的“<em>控制权</em>”，因此需要一个<strong>中间件</strong>来转换它们之间的消息、编排需要多个 Web 服务参与的业务流程，等等。</p><p>还有一点值得记住，ESB 的实现已经发展了很久，现在，大多数用例甚至用简单的 UI 拖拽就可以完成 ESB 的配置。</p><h2 id=优点-3>优点</h2><ul><li>服务与技术栈无关，服务可以独立部署和扩展；</li><li>通用、简单以及可靠的通信通道(通过 HTTP 80 端口的文本)；</li><li>最优的通信；</li><li>稳定的通信标准；</li><li>领域上下文隔离；</li><li>服务可以轻松地连接和断开；</li><li>通过异步通信控制系统负载；</li><li><strong>单点的版本和转换管理。</strong></li></ul><h2 id=缺点-3>缺点</h2><ul><li><p>较慢的通信速度，尤其是那些本来就兼容的服务；</p></li><li><p>集中化的逻辑：</p><ul><li>单点故障可以造成企业内所有通信宕机；</li><li>配置和维护过于复杂；</li><li>ESB 最终可能包含业务规则；</li><li>其复杂程度最终会需要一个团队专门管理；</li><li>服务变得及其依赖 ESB。</li></ul></li></ul><h1 id=微服务>微服务</h1><p>微服务架构以 SOA 概念为基础，与 ESB 有着同样的全局目标：将多个特定的业务领域应用整合为一个全局应用。</p><p>它和 ESB 之间的关键区别在于，ESB 诞生的上下文是<strong>独立应用需要集成</strong>实现企业范围内的分布式应用，而微服务架构诞生的上下文则是快节奏和不断变化的<strong>业务</strong>，它们通常需要从头<strong>创建自己的云应用</strong>。</p><p>换句话说，它们的出发点不同。就 ESB 来说，我们一开始就要面对<strong>没有“控制权“”的已有应用</strong>，不能修改它们。而对微服务来说，我们<strong>可以完全控制应用</strong>（这并不是说系统不能涉及任何第三方 Web 服务）。</p><p>微服务构建和设计的方式不需要高度的集成。微服务应该专注于一个业务概念，一个限界上下文，它们自己管理自己的状态，这样就不会直接依赖其它微服务，因此需要的集成更少。换句话说，微服务的高内聚低耦合带来了不错的副作用，即减少了集成的需要。</p><blockquote><p>[微服务是]一起工作的小型的自治服务，它们围绕着业务领域进行建模。—— Sam Newman 2015,
<a href="https://youtu.be/PFQnNFe27kU?t=1m50s" target=_blank>Principles Of Microservices</a></p></blockquote><p>既然 ESB 架构最大的弊端在于它过于复杂，而且所有其它应用都得依赖一个中心应用，所以微服务架构几乎完全去掉了中心应用，来解决这个问题。</p><p>仍然会有一些元素横切整个微服务生态系统，但它们并没有像 ESB 那样承担这么多职责。例如，依然会存在用于微服务间异步通信的消息队列，但它只是一个纯粹的消息管道，没有其它职责。另一个例子是微服务生态系统的网关，所有和外界的通信都由它完成。</p><p><em><a href=https://www.amazon.co.uk/d/Books/Building-Microservices-Sam-Newman/1491950358 target=_blank>Building Microservices</a></em> 一书的作者 Sam Newman 指出了微服务架构的八条原则：</p><ul><li><strong>服务要围绕业务领域建模</strong>
因为它能带给我们围绕业务概念的稳定接口、高度内聚和解耦的代码单元以及清晰可见的限界上下文；</li><li><strong>自动化的文化</strong>
因为我们会拥有多得多的活动部件和部署单元；</li><li><strong>隐藏实现细节</strong>
让服务可以互不干扰，独自演进；</li><li><strong>一切都是去中心化的</strong>
决策权力和架构概念都是去中心化的，将自治权下放给团队，这样组织会将自己转变成一个复杂的自适应系统，能够快速适应变化；</li><li><strong>独立部署</strong>
这样无需任何改变我们就能部署一个新版本的服务；</li><li><strong>消费者优先</strong>
服务应该很容易被消费，很容易被其它服务使用；</li><li><strong>隔离故障</strong>
这样即使一个服务宕机，其它服务仍可以继续工，让整个系统保持很高的失败恢复能力；</li><li><strong>高度可观察</strong>
由于系统部件数量众多，想要理解系统的方方面面更加困难，所以我们需要成熟的监控工具，让我们掌握发生在系统每个角落里的细节，理解每一个连锁反应。</li></ul><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-6b9b863ce986f536.jpg alt=img></p><blockquote><p>微服务社区青睐另一种方法：<strong>智能终端节点和哑管道</strong>。基于微服务构建的应用以尽可能的解耦和内聚为目标 —— 它们拥有自己的领域逻辑，并且表现得更像经典 Unix 感觉的过滤器 —— 接收一个请求，酌情运用逻辑并生成一个响应。这些都使用简单的 REST 风格的协议进行编排，而不是类似 WS-Choreography 或 BPEL 或由中心工具编排的复杂协议。—— Martin Fowler 2014,
<a href=https://martinfowler.com/articles/microservices.html target=_blank>Microservices</a></p></blockquote><h2 id=优点-4>优点</h2><ul><li>服务与技术栈无关，服务可以独立部署和扩展；</li><li>通用、简单以及可靠的通信通道(通过 HTTP 80 端口的文本)；</li><li>最优的通信；</li><li>稳定的通信标准；</li><li>领域上下文隔离；</li><li>服务可以轻松地连接和断开；</li><li>通过异步通信控制系统负载；</li><li><strong>同步通信有益于管理系统性能；</strong></li><li><strong>真正独立和自治的服务；</strong></li><li><strong>业务逻辑都存在于服务内部；</strong></li><li><strong>将组织转变成由一些小型自治的部件/团队组成的可以快速适应业务变化的*复杂适应性系统*的可能性。</strong></li></ul><h2 id=缺点-4>缺点</h2><ul><li><p>运维复杂度高：</p><ul><li>需要大量投入建立牢固的 DevOps 文化；</li><li>多种技术和库的运用可能导致失控；</li><li>输入和输出 API 的变更必须进行细致的管理，因为这些接口被软件依赖；</li><li>最终一致性的使用影响巨大，必须在开发应用时处理，从后端到 UX 层全部都要考虑 ；</li><li>测试更加复杂，因为接口的变化可能给其它服务带来无法预测的后果。</li></ul></li></ul><h1 id=反模式意式馄饨架构>反模式：意式馄饨架构</h1><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-5a581a259238d2b5.png alt=img></p><p><em>意式馄饨架构</em>这个名字通常指的是<strong>微服务架构的反模式</strong>。如果我们最终创建了一个这样的微服务生态系统，其中有太多微服务，而这些微服务太小本身也不能代表领域概念时，这种反模式就会发生。</p><h1 id=总结>总结</h1><p>SOA 在最近几十年里已经取得了长足的进步，实现方案和技术优势的不足最终促成了微服务架构。</p><p>整个变化的背后蕴含着我们解决复杂问题的常规策略：将问题分解成更小的可以解决的碎片。</p><p>在我们将一个单体拆分成解耦的领域组件（限界上下文）时，也可以使用同样的方式解决代码复杂性。但是，随着团队和代码规模的增长，独立演进、扩展和部署的需求也在不断增加。SOA 提供了实现这些独立性的工具，强制在限界上下文之间确立更严格的边界。</p><p><img src=16-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-0287a76b0050c066.gif alt=img></p><p>高内聚低耦合再一次得到了体现，这次是在比之前更粗的粒度上。同样，实用主义在分析我们的需求时也非常重要：只有在真正需要时使用 SOA，因为它会带来很多复杂性，而如果<strong>我们确实
需要使用 SOA</strong>，就创建<strong>满足我们需求的大小和数量</strong>的微服务，不要多也不要少。</p><h1 id=引用来源>引用来源</h1><p>1997 – Steve Vinoski –
<a href="https://www.google.nl/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjNjcrh-a3SAhXMCywKHWFgAEwQFggdMAA&url=http%3A%2F%2Fwww.cs.wustl.edu%2F~schmidt%2FPDF%2Fvinoski.pdf&usg=AFQjCNGHgp0XUqdxj7IF5pKEGNr8KSop2A&sig2=5dDa9AU9WVrxa7d64Ih88g&bvm=bv.148073327,d.bGg" target=_blank>CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments</a><br>2000 – Roy Fielding –
<a href="https://www.google.nl/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&cad=rja&uact=8&ved=0ahUKEwjxhZPc_K3SAhUFtRQKHSFJBUsQFggsMAE&url=https%3A%2F%2Fwww.ics.uci.edu%2F~fielding%2Fpubs%2Fdissertation%2Ffielding_dissertation.pdf&usg=AFQjCNEEwS3STct3jnKXToOQXO15Q4cY1g&sig2=7B1V07RRh9X6vFTcFVRMVQ" target=_blank>Architectural Styles and the Design of Network-based Software Architectures</a><br>2004 – Microsoft –
<a href=https://msdn.microsoft.com/en-us/library/ff647328.aspx target=_blank>Message Bus</a><br>2004 – Microsoft –
<a href=https://msdn.microsoft.com/en-us/library/aa480021.aspx target=_blank>Understanding Service-Oriented Architecture</a><br>2011 – Chris Ostrowski –
<a href="https://www.youtube.com/watch?v=0hyXOuvyq2Q" target=_blank>Understanding Oracle SOA – Part 1 – Architecture</a><br>2011 – Chris Ostrowski –
<a href="https://www.youtube.com/watch?v=zNvyCUO0dyw" target=_blank>Understanding Oracle SOA – Part 2 – Technologies</a><br>2011 – Chris Ostrowski –
<a href="https://www.youtube.com/watch?v=0J4iHaUOpzU" target=_blank>Understanding Oracle SOA – Part 3 – Development</a><br>2011 – Chris Ostrowski –
<a href="https://www.youtube.com/watch?v=t9-kj1veqXk" target=_blank>Understanding Oracle SOA – Part 4 – Business Benefits</a><br>2012 – Prabhu –
<a href=http://www.mudskipper-solutions.com/home/service-oriented-architecture-soa target=_blank>Service Oriented Architecture – SOA</a><br>2014 – Martin Fowler –
<a href=https://martinfowler.com/articles/microservices.html target=_blank>Microservices</a><br>2014 – PWC –
<a href=http://www.pwc.com/us/en/technology-forecast/2014/cloud-computing/features/microservices.html target=_blank>Agile coding in enterprise IT: Code small and local</a><br>2015 – Udi Dahan –
<a href="https://www.youtube.com/watch?v=CVc3d4hrH6Y" target=_blank>Messaging Architecture and Services Bus</a><br>2015 – Sam Newman –
<a href="https://www.youtube.com/watch?v=PFQnNFe27kU" target=_blank>Principles Of Microservices</a><br>2016 – Kai Wähner –
<a href="https://www.youtube.com/watch?v=fITFdDU5L9w" target=_blank>Microservices: Death of the Enterprise Service Bus?</a><br>2016 – Abraham Marín Pérez –
<a href=https://www.infoq.com/news/2016/06/corba-removed-java-9 target=_blank>Java 9 Will Remove CORBA from Default Classpath</a><br>2016 – Oracle –
<a href=http://docs.oracle.com/javase/7/docs/technotes/guides/idl/corba.html target=_blank>CORBA Technology and the Java™ Platform Standard Edition</a><br>2017 – Wikipedia –
<a href=https://en.wikipedia.org/wiki/Distributed_object_communication target=_blank>Distributed object communication</a><br>2017 – Wikipedia –
<a href=https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture target=_blank>Common Object Request Broker Architecture</a><br>2017 – Wikipedia –
<a href=https://en.wikipedia.org/wiki/Enterprise_service_bus target=_blank>Enterprise service bus</a><br>2017 – Wikipedia –
<a href=https://en.wikipedia.org/wiki/Representational_state_transfer target=_blank>Representational State Transfer</a><br>2017 – Wikipedia –
<a href=https://en.wikipedia.org/wiki/SOAP target=_blank>SOAP</a><br>2017 – Wikipedia –
<a href=https://en.wikipedia.org/wiki/Service-oriented_architecture target=_blank>Service-oriented architecture</a><br>2017 – Microsoft –
<a href=https://msdn.microsoft.com/en-us/library/bb833022.aspx target=_blank>Enterprise Architecture: SOA in the real world</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>p3p3pp3</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-05-16</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/architecture.html>architecture</a>
<a href=/tags/soa.html>SOA</a></div><nav class=post-nav><a class=prev href=/post/2021/software-architecture/17-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8401.html><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">17.清晰架构01-融合 DDD、洋葱架构、整洁架构、CQRS.</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/2021/software-architecture/15-%E4%BB%8Ecqs%E5%88%B0cqrs.html><span class="next-text nav-default">15.从CQS到CQRS</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="p3sblog",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://p3p3pp3.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>p3p3pp3</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-134997356-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script id=baidu_push>(function(){if(window.location.hostname==="localhost")return;var t,n,e=document.createElement("script");e.async=!0,n=window.location.protocol.split(":")[0],n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>