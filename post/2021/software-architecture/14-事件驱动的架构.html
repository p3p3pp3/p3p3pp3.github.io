<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>14.事件驱动的架构 - P3的Blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="p3p3pp3"><meta name=description content="原文：https://herbertograca.com/2017/10/05/event-driven-architecture/ 这篇文章"><meta name=keywords content="P3,blog,coding"><meta name=baidu-site-verification content="code-rMlGvJbrZW"><meta name=google-site-verification content="iTJj3dp57yfylJL_-Z2_nwxz5Dz6jnf1xAwgKb6TS_g"><meta name=generator content="Hugo 0.104.3 with theme even"><link rel=canonical href=https://p3p3pp3.github.io/post/2021/software-architecture/14-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84.html><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="14.事件驱动的架构"><meta property="og:description" content="原文：https://herbertograca.com/2017/10/05/event-driven-architecture/ 这篇文章"><meta property="og:type" content="article"><meta property="og:url" content="https://p3p3pp3.github.io/post/2021/software-architecture/14-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-05-16T14:00:50+08:00"><meta property="article:modified_time" content="2021-05-16T14:00:50+08:00"><meta itemprop=name content="14.事件驱动的架构"><meta itemprop=description content="原文：https://herbertograca.com/2017/10/05/event-driven-architecture/ 这篇文章"><meta itemprop=datePublished content="2021-05-16T14:00:50+08:00"><meta itemprop=dateModified content="2021-05-16T14:00:50+08:00"><meta itemprop=wordCount content="5646"><meta itemprop=keywords content="architecture,CQRS,"><meta name=twitter:card content="summary"><meta name=twitter:title content="14.事件驱动的架构"><meta name=twitter:description content="原文：https://herbertograca.com/2017/10/05/event-driven-architecture/ 这篇文章"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P3的Blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post.html><li class=mobile-menu-item>Archives</li></a><a href=/tags.html><li class=mobile-menu-item>Tags</li></a><a href=/categories.html><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P3的Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post.html>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags.html>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories.html>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>14.事件驱动的架构</h1><div class=post-meta><span class=post-time>2021-05-16</span>
<span class=more-meta>约 5646 字</span>
<span class=more-meta>预计阅读 12 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#何物何时何因>何物/何时/何因</a><ul><li><a href=#1-解耦组件>1. 解耦组件</a></li><li><a href=#2-执行异步任务>2. 执行异步任务</a></li><li><a href=#3-跟踪状态变化审计日志>3. 跟踪状态变化（审计日志）</a></li></ul></li><li><a href=#监听器-vs-订阅者>监听器 vs. 订阅者</a></li><li><a href=#模式>模式</a><ul><li><a href=#事件通知>事件通知</a><ul><li><a href=#优点>优点</a></li><li><a href=#缺点>缺点</a></li></ul></li><li><a href=#事件携带的状态转换>事件携带的状态转换</a><ul><li><a href=#优点-1>优点</a></li><li><a href=#缺点-1>缺点</a></li></ul></li><li><a href=#事件溯源>事件溯源</a><ul><li><a href=#事务日志>事务日志</a></li><li><a href=#删除>删除</a></li><li><a href=#快照>快照</a></li><li><a href=#投影>投影</a></li><li><a href=#优点和缺点>优点和缺点</a></li></ul></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#引用来源>引用来源</a></li></ul></nav></div></div><div class=post-content><p>原文：https://herbertograca.com/2017/10/05/event-driven-architecture/</p><p><em>这篇文章是
<a href=https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/ target=_blank>软件架构编年史</a>(
<a href=https://www.jianshu.com/p/b477b2cc6cfa target=_blank>译</a>)的一部分，这部编年史由
<a href=https://herbertograca.com/category/development/series/software-architecture/ target=_blank>一系列关于软件架构的文章</a>组成。在这一系列文章中，我将写下我对软件架构的学习和思考，以及我是如何运用这些知识的。如果你阅读了这个系列中之前的文章，本篇文章的的内容将更有意义。</em></p><p>使用事件来设计应用似乎是上个世纪八十年代后期的实践。我们可以在前端后端任何地方使用事件。当按钮被按下时，当数据变化时，又或是后端操作执行时。</p><p>但事件的准确定义是什么？我们何时该使用它？又该如何使用它？它的缺点又是什么？</p><h1 id=何物何时何因>何物/何时/何因</h1><p>和类、组件应该保持相互之间的低耦合与自身内部的高内聚一样。当组件需要协作时，比如组件“A”需要触发组件“B”中的某段逻辑，自然而然的方法就是简单地让组件 A 调用组件 B 的一个对象的方法。然而，如果 A 知道了 B 的存在，那么它们就产生了耦合，即 A 依赖 B，这让系统更难变化和维护。而事件可以用来<strong>避免耦合</strong>。</p><p>而且，由于事件的使用和解耦组件带来的副作用，如果有团队只在组件 B 上工作，他们甚至不用和负责组件 A 的团队商量就可以改变组件 B 对组件 A 中的逻辑的响应。组件可以独立地演进：<strong>我们的应用变得更有机（？？）了</strong>。</p><p>即便是在同一个组件中，有时我们也会有一段需要作为操作结果执行的代码，但是不需要在同一次请求/响应回合中立即执行。最明显的例子就是发邮件了。在这种情况下，我们可以立即向用户返回一个响应，并在稍后以<strong>异步</strong>方式发送电子邮件，从而避免用户等待电子邮件的发送。</p><p>然而，这里也有不少坑。如果我们不假思索地使用事件，就会产生风险，最终概念上高度内聚的逻辑流程却使用了事件来串联，而这本该是一种解耦的机制。换句话说，本应放在一起的代码被分开了，脉络很难理清（这和<em>goto</em>语句很像），理解和推断都很难：代码将变成意大利面！</p><p>要防止我们的代码库变成一坨意大利面代码，我们应该只在明确识别出来的情况下使用事件。根据我的经验，有以下三种情形需要使用事件：</p><ol><li>解耦组件</li><li>执行异步任务</li><li>跟踪状态变化（审计日志）</li></ol><h2 id=1-解耦组件>1. 解耦组件</h2><p>当组件 A 执行的逻辑需要触发组件 B 的逻辑时，它会触发一个事件发送给事件派发器，而不是直接调用 B 的逻辑。组件 B 会监听事件派发器中这个特殊的事件，在该事件发生时做出响应。</p><p>这意味着 A 和 B 都将依赖派发器和事件，但它们却互不知晓：它们是解耦的。</p><p>理想情况下，派发器和事件不应该属于任何组件：</p><ul><li>派发器应该是一个完全独立于应用的库，因此使用依赖管理系统安装在
一个通用的地址。在 PHP 中，它使用
<a href=https://getcomposer.org/ target=_blank>Composer</a> 安装在 <em>vendor</em> 目录中的东西。</li><li>然而，事件却是应用的一部分，但是为了让组件互相无感，它应该不属于任何组件。事件就是 DDD 中称为<strong>共享内核</strong>的部分。这样一来，两个组件都依赖共享内核但仍然互相无感。
但是在单体应用中，为了方便，将事件放在触发它的组件中也是可以接受的。</li></ul><blockquote><p>共享内核</p><p>[…] 团队就要共享的领域模型中的子集达成一致，用一条清晰的边界将其标明。保持内核小巧。[…] 这些显式共享的东西有着特殊的状态，没有和其它团队沟通的情况下不应该修改。</p><p>Eric Evans 2014,
<a href=https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-Summaries/dp/1457501198 target=_blank>Domain-Driven Design Reference</a></p></blockquote><h2 id=2-执行异步任务>2. 执行异步任务</h2><p>有时候我们有一段想要执行的逻辑，但它可能需要一些时间来执行，而我们又不希望让用户等它执行完成。这种情况下，人们希望将它作为一个异步的工作执行，并立即返回一条消息给用户，通知他他的请求将在稍后异步执行。</p><p>例如，在网店上下单可以同步完成，而发送邮件通知用户可以异步完成。</p><p>这些情况下，我们能做的是触发一个事件放到队列中，事件将在队列中等待直到有程序在系统有资源的时候能接收并执行它。</p><p>这些情形下，相关逻辑是否属于同一个上下文无关紧要，逻辑是解耦的。</p><h2 id=3-跟踪状态变化审计日志>3. 跟踪状态变化（审计日志）</h2><p>用传统方式保存数据时，我们用实体持有某些数据。当这些实体之中的数据变化时，我们简单地将数据库表中的行更新成新的值。</p><p>这里的问题是，我们没有保存是什么发生了变化以及何时发生的变化。</p><p>我们可以用一种<em>审计日志</em>的结构保存包含变化的事件。</p><p>稍后介绍<em>事件溯源</em>时还有更多详细解释。</p><h1 id=监听器-vs-订阅者>监听器 vs. 订阅者</h1><p>在实现事件驱动架构时常见的争论就是使用事件监听器还是事件订阅者，所以在这里澄清一下我的观点：</p><ol><li><strong>事件监听器</strong>只会响应一种事件，并有多个方法来响应它。因此我们应该根据事件名称来命名监听器，例如，如果我们有一个“<em>UserRegisteredEvent</em>”事件，那么就会一个“<em>UserRegisteredEventListener</em>”监听器。这样，即使不查看文件内部，也可以很容易地知道监听器正在监听什么事件。响应事件的方法（反应）应该体现出该方法做了什么，例如，“<em>notifyNewUserAboutHisAccount()</em>”和“<em>notifyAdminThatNewUserHasRegistered()</em>”。大多数情况下这应该是常规做法，因为它保持监听器的小巧并让监听器专注于单一职责，即响应特定的事件。还有，如果我们采用了组件化架构，每个组件可以拥有自己的监听器，它监听的事件可能从多个地方触发。</li><li><strong>事件订阅者</strong>可以响应多种事件，并有多个方法来响应它。订阅者的命名更加困难，因为它不能特有所指，然而订阅者仍然需要遵循单一职责原则，订阅者的名字需要体现出它的单一意图。事件订阅者的使用应该是更少见的方式，尤其是在组件内部，因为单一职责原则很容易被破坏。正确使用事件订阅者的一个例子是事务管理，具体点说就是我们可以采用一个名为“<em>RequestTransactionSubscriber</em>”的事件订阅者，它要响应“<em>RequestReceivedEvent</em>”、“<em>ResponseSentEvent</em>”和“<em>KernelExceptionEvent</em>”三个事件，分别绑定到事务的开始、结束和回滚，每个操作都有各自的方法，如“<em>startTransaction()</em>”, “<em>finishTransaction()</em>”和“<em>rollbackTransaction()</em>”。这个事件订阅者可以响应多种事件但仍然专注于管理请求事务的单一职责。</li></ol><h1 id=模式>模式</h1><p>Martin Fowler 识别出了三种不同类型的事件模式：</p><ul><li>事件通知</li><li>事件携带的状态转换</li><li>事件溯源</li></ul><p>这些模式有着同样的关键概念：</p><ol><li>事件表达了某事已经发生（它们在某事后发生）；</li><li>事件被广播给监听它的任意代码（一个事件能被多个代码单元响应）。</li></ol><h2 id=事件通知>事件通知</h2><p>假设我们有一个应用核心，其组件定义清晰。理想情况下，这些组件之间是完全解耦的，但是，它们的某些功能需要<strong>执行其它组件中的逻辑</strong></p><p>这是最典型的情况，之前已经描述过：当组件 A 执行的逻辑需要触发组件 B 的逻辑时，它会触发一个事件发送给事件派发器，而不是直接调用 B 的逻辑。组件 B 会监听事件派发器中这个特殊的事件，在该事件发生时做出响应。</p><p>有一点要特别指出，这种模式有一个特点，<strong>事件只会携带最少的数据</strong>。它只会携带足够让监听器能知道发生了什么并能执行它们的代码的数据，通常就只有实体 ID（可以是多个）以及事件发生的日期和时间。</p><h3 id=优点>优点</h3><ul><li>更好的可恢复性，如果事件被放入了队列，即便第二段逻辑因为出现问题不能在当下执行，来源组件依然可以执行它自己的逻辑（因为事件被放入队列，它们可以稍后在问题修复后再执行）。</li><li>低延迟，如果事件被放入了队列，用户就不用等着逻辑执行完成；</li><li>团队可以独立地演进组件，他们的工作更简单、完成得更快、问题更少、更有机（？？）。</li></ul><h3 id=缺点>缺点</h3><ul><li>如果不能规范地使用，有可能把代码库变成一堆意大利面代码。</li></ul><h2 id=事件携带的状态转换>事件携带的状态转换</h2><p>我们还是以前面这个有着清晰定义的组件的应用核心为例。这一次，它们有些功能<strong>需要其它组件的数据</strong>。获取这些数据最顺其自然的方式就是问其它的组件要，但这意味着发起查询的组件将知道被查询的组件的信息：这两个组件耦合在了一起！</p><p>另一种分享数据的方式是使用拥有该数据的组件在数据变化时所触发的事件。<strong>这些事件会携带完整的新版本数据</strong>。对该数据有兴趣的组件会监听这些事件并通过在保存该数据的本地副本来响应它们。这样，当它们需要外部数据时，它们可以在本地找到，就不用向其他组件查询了。</p><h3 id=优点-1>优点</h3><ul><li>更好的可恢复性，因为即便被查询的组件不可用（不管是出现问题还是远程服务器无法访问），发起查询的组件依然可以工作。</li><li>低延迟，因为没有远程调用（如果被查询的组件是远程组件）；</li><li>我们不用担心被查询组件的负载是否可以支撑全部发起查询的组件的查询（特别是这些组件是远程组件的话）。</li></ul><h3 id=缺点-1>缺点</h3><ul><li>同样的数据存在多个副本，即便都是只读的，即便数据存储现在不再是问题了。</li><li>发起查询的组件复杂性更高，因为它需要逻辑来维的护外部数据在本地的拷贝，尽管这些逻辑相当的标准。</li></ul><p>如果两个组件都在同一个进程中执行（这让组件间的通信比较迅速），这种模式可能是不必要的，但即便是这样，为了追求解耦和可维护性或是为了准备好在未来某个时间点将这些组件解耦成微服务，这种模式仍然是有吸引力的。这完全取决于我们现在和未来的需要，以及我们期望/需要多大程度的解耦。</p><h2 id=事件溯源>事件溯源</h2><p>假设一个实体处于初始状态。作为一个实体，它有自己的身份标识，它是应用要建模的真实世界中的一个特定事物。伴随着它的生命周期，实体数据不断变化，而传统的做法是，将实体的当前状态简单地保存为数据库中一行。</p><h3 id=事务日志>事务日志</h3><p>上面这种方法大多数情况下都可以工作得很好，但是如果我们想要知道实体是如何到达这个状态的呢（比如，我们想知道银行账号得贷项和借项）？这种方法就做不到了，因为我们知保存了当前状态！</p><p>如果使用事件溯源，而不是保存实体状态，我们就能专注于保存实体的状态<strong>变化</strong>并根据这些变化<strong>计算出实体状态</strong>。每一次状态变化都是一个事件，保存在事件流中（比如，关系型数据库中的一张表）。当我们需要实体的当前状态，我们将根据事件流中它的全部事件计算出来。</p><blockquote><p>事件存储变成了事实的主要来源，而系统状态完全由之推导而来。对程序员来说，版本管理系统就是最好的例子。所有的提交记录就是事件存储，而源代码树的工作副本就是系统状态。</p><p>Greg Young 2010,
<a href=https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf target=_blank>CQRS Documents</a></p></blockquote><h3 id=删除>删除</h3><p>如果有一次状态变化（事件）是错误的，我们不能简单地删除该事件，因为这样做会改变状态变化的历史，会违反整个事件溯源的理念。相反地，我们应该在事件流中创建一个事件，撤销我们想要删除的事件。这个过程被称作逆转事务，它不仅要将实体带回期望的状态，还要<em>留下展示该对象在给定时间点处于该状态的轨迹</em>。</p><blockquote><p>保留数据还会带来架构上的好处。存储系统变成了一个递增的架构，众所周知只能追加的架构并一直更新的架构更容易变成分布式，因为要处理的锁会更少。</p><p>Greg Young 2010,
<a href=https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf target=_blank>CQRS Documents</a></p></blockquote><h3 id=快照>快照</h3><p>但是，当我们有太多事件流中的事件时，计算实体状态的代价很大，性能很差。要解决这个问题，每 X 个事件，我们都会在这个节点创建一个实体状态的快照。这样的话，当我们需要实体状态时，我们只用从最后一个快照开始计算。见鬼，我们甚至可以保留一个永远更新的实体快照，鱼与熊掌兼得。</p><p><img src=14-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84.assets/4099-100f8a4eaac098b2.png alt=img></p><p>2006-2-event-sourcing.png</p><h3 id=投影>投影</h3><p>在事件溯源中，我们还有一个概念叫做<strong>投影</strong>，它是对事件流中给定起始时刻之间的事件的计算。这意味着快照、或者实体的当前状态，都符合投影的定义。但是，投影概念中最有价值的理念是我们可以分析特定时间段内实体的“行为”，让我们对未来作出有根据的猜测（例如，如果在过去五年中，实体在八月的活动都有所增加，那么很能在接下来的八月中也会发生同样的事情），这种能力对公司来说非常有价值。</p><h3 id=优点和缺点>优点和缺点</h3><p>事件溯源对业务流程和开发流程都很有帮助：</p><ul><li>我们查询这些事件，有助于从业务侧和开发侧两方面理解用户和系统的行为（调试）；</li><li>我们还可以使用事件日志来重建过去的状态，对业务和开发也都很有帮助；</li><li>自动调整状态，以应对追溯性变化，对业务大有裨益;</li><li>在重放时注入假想事件来探索另一种的历史，对业务来说太棒了。</li></ul><p>但也并不是事事顺心，要小心潜在的问题：</p><ul><li><p><strong>外部的更新</strong></p><p>如果我们的事件要触发外部系统中的更新，当我们为了创建投影而重放事件时我们不希望重新触发这些事件。这时，我们可以在“重放模式”中简单地禁用外部更新，可能会将这段逻辑封装在网关中。
还有一种解决方法，要依实际问题而定，可以将对外部系统的更新缓冲起来，在一段时间后当可以肯定这些事件不会被重放时在、再执行它们，</p></li><li><p><strong>外部的查询</strong></p><p>如果我们的事件要使用对外部系统的查询，例如，获得股票债券评级，当我们为了创建投影而重放事件时会发生什么？我们可能期望得到和第一次执行这些事件时（可能是几年之前）一样的评级。所以，要么远程应用可以将这些值给我们，要么我们需要在自己的系统中保存它们，这样我们就能模拟远程查询，同样地，这段逻辑将被封装在网关里。</p></li><li><p><strong>代码变化</strong></p><p>Martin Fowler 识别出了三种类型的代码变化：<em>新特性</em>、<em>问题修复</em>以及*临时逻辑。当应该用不同的业务逻辑规则在不同的时间点播放的事件被重放时，真正的问题就出现了。例如，去年的税收计算与今年不同。通常情况下，可以使用条件逻辑，但它会变得混乱，因此建议使用策略模式。</p></li></ul><p>因此，我建议谨慎使用，只要有可能，我会遵守以下规则：</p><ul><li>保持事件简单，只和状态变化有关，和变化如何决策无关。这样的话我们可以安全地重放任何事件，即使业务规则同一时间内发生了变化我们也可以期望同样的结果（尽管我们要保留遗留的业务规则，我们才能在重放过去的事件时应用它们）；</li><li>与外部系统的交互不应该依赖这些事件，这样我们就可以安全地重放事件，不存在重新触发外部逻辑的危险，而且我们不需要保证外部系统的回复和一开始播放这些事件时是一样的。</li></ul><p>而且，当然，和其它模式一样，我们不用在所有地方使用它，我们应该在有效的地方使用它，当它可以为我们带来优势使用它，当它解决的问题比带来的问题更多时使用它。</p><h1 id=总结>总结</h1><p>再一次，这主要关于封装、低耦合和高内聚。</p><p>事件可以为可维护性、性能和代码库的扩张带来巨大的好处，但是，要通过事件溯源，它还可以为系统数据提供的可靠性和信息带来巨大的好处。</p><p>然而，这是一条布满荆棘的道路，因为概念复杂性和技术复杂性都在增加，滥用其中任何一种都可能带来灾难性的后果。</p><h1 id=引用来源>引用来源</h1><p>2005 – Martin Fowler –
<a href=https://martinfowler.com/eaaDev/EventSourcing.html target=_blank>Event Sourcing</a><br>2006 – Martin Fowler –
<a href=https://martinfowler.com/eaaDev/EventNarrative.html target=_blank>Focusing on Events</a><br>2010 – Greg Young –
<a href=https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf target=_blank>CQRS Documents</a><br>2014 – Greg Young –
<a href="https://www.youtube.com/watch?v=JHGkaShoyNs" target=_blank>CQRS and Event Sourcing – Code on the Beach 2014</a><br>2014 – Eric Evans –
<a href=https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-Summaries/dp/1457501198 target=_blank>Domain-Driven Design Reference</a><br>2017 – Martin Fowler –
<a href=https://martinfowler.com/articles/201701-event-driven.html target=_blank>What do you mean by “Event-Driven”?</a><br>2017 – Martin Fowler –
<a href="https://www.youtube.com/watch?v=STKCRSUsyP0" target=_blank>The Many Meanings of Event-Driven Architecture</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>p3p3pp3</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-05-16</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/architecture.html>architecture</a>
<a href=/tags/cqrs.html>CQRS</a></div><nav class=post-nav><a class=prev href=/post/2021/software-architecture/15-%E4%BB%8Ecqs%E5%88%B0cqrs.html><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">15.从CQS到CQRS</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/2021/software-architecture/13-%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84.html><span class="next-text nav-default">13.整洁架构</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="p3sblog",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://p3p3pp3.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2017 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>p3p3pp3</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-134997356-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script id=baidu_push>(function(){if(window.location.hostname==="localhost")return;var t,n,e=document.createElement("script");e.async=!0,n=window.location.protocol.split(":")[0],n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>