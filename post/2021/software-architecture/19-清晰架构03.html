<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>19.清晰架构03-在代码中展现架构和领域 - P3的Blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="p3p3pp3"><meta name=description content="原文：https://herbertograca.com/2019/06/05/reflecting-architecture-and-do"><meta name=keywords content="P3,blog,coding"><meta name=baidu-site-verification content="code-rMlGvJbrZW"><meta name=google-site-verification content="iTJj3dp57yfylJL_-Z2_nwxz5Dz6jnf1xAwgKb6TS_g"><meta name=generator content="Hugo 0.83.1 with theme even"><link rel=canonical href=https://p3p3pp3.github.io/post/2021/software-architecture/19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.html><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="19.清晰架构03-在代码中展现架构和领域"><meta property="og:description" content="原文：https://herbertograca.com/2019/06/05/reflecting-architecture-and-do"><meta property="og:type" content="article"><meta property="og:url" content="https://p3p3pp3.github.io/post/2021/software-architecture/19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-05-16T14:02:27+08:00"><meta property="article:modified_time" content="2021-05-16T14:02:27+08:00"><meta itemprop=name content="19.清晰架构03-在代码中展现架构和领域"><meta itemprop=description content="原文：https://herbertograca.com/2019/06/05/reflecting-architecture-and-do"><meta itemprop=datePublished content="2021-05-16T14:02:27+08:00"><meta itemprop=dateModified content="2021-05-16T14:02:27+08:00"><meta itemprop=wordCount content="4371"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="19.清晰架构03-在代码中展现架构和领域"><meta name=twitter:description content="原文：https://herbertograca.com/2019/06/05/reflecting-architecture-and-do"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P3的Blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post.html><li class=mobile-menu-item>Archives</li></a><a href=/tags.html><li class=mobile-menu-item>Tags</li></a><a href=/categories.html><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P3的Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post.html>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags.html>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories.html>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>19.清晰架构03-在代码中展现架构和领域</h1><div class=post-meta><span class=post-time>2021-05-16</span>
<span class=more-meta>约 4371 字</span>
<span class=more-meta>预计阅读 9 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#我的两张脑图>我的两张脑图</a></li><li><a href=#体现架构的代码风格>体现架构的代码风格</a></li><li><a href=#让架构清晰的展现出来>让架构清晰的展现出来</a><ul><li><a href=#用户界面>用户界面</a></li><li><a href=#基础设施>基础设施</a></li><li><a href=#核心>核心</a></li><li><a href=#用户区里的编程语言扩展>用户区里的编程语言扩展</a></li></ul></li><li><a href=#强化架构>强化架构</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class=post-content><p>原文：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fherbertograca.com%2F2019%2F06%2F05%2Freflecting-architecture-and-domain-in-code%2F">https://herbertograca.com/2019/06/05/reflecting-architecture-and-domain-in-code/</a></p><p><em>这篇文章是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fherbertograca.com%2F2017%2F07%2F03%2Fthe-software-architecture-chronicles%2F">软件架构编年史</a>(<a href=https://www.jianshu.com/p/b477b2cc6cfa>译</a>)的一部分，这部编年史由<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fherbertograca.com%2Fcategory%2Fdevelopment%2Fseries%2Fsoftware-architecture%2F">一系列关于软件架构的文章</a>组成。在这一系列文章中，我将写下我对软件架构的学习和思考，以及我是如何运用这些知识的。如果你阅读了这个系列中之前的文章，本篇文章的的内容将更有意义。</em></p><p>在创建应用的时候，让它可以工作易如反掌。要让它在处理大量数据的情况下仍然保持性能，会有点困难。但是最难的挑战是构建一个真正可以维系多年（十年、二十年甚至一百年）的应用程序。</p><p>我工作过的大多数公司都有每三到五年就重建应用的历史，有时甚至不到两年就要重建。这种做法成本极高，它将极大地影响应用程序的成功，进而极大地影响公司的成功，还会让开发人员在乱成一锅粥的代码库种凌乱，让他们想萌生辞职的想法。任何一家志向远大的正经公司，都无法承受任何经济上、时间上、声誉上、客户上、人才上的损失。</p><p>让应用程序保持可维护性的基石是让代码能够反映出架构和领域，这对防止所有棘手问题至关重要。</p><p><strong>清晰架构</strong>是对比我经验更丰富的开发者所倡导的原则以及实践的合理解释，也是对我如何组织代码库使之反映出项目架构与领域并便于沟通的经验总结。</p><p>在我的<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fherbertograca.com%2F2017%2F11%2F16%2Fexplicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together%2F">上一篇博客</a>（<a href=https://www.jianshu.com/p/d3e8b9ac097b>译文</a>）里，我将这些理念汇总起来并用信息图和 UML 图呈现，试图建立我思考的概念图谱。</p><p>然而，我们怎样才能把实践落实到代码中呢？</p><p>在这篇博客里，我将说明我是如何在代码中体现一个项目的结构和领域的，还将提出一个通用的结构，我认为它能帮助我们规划好可维护性。</p><h2 id=我的两张脑图>我的两张脑图</h2><p>在这个系列的前两篇文章里我介绍了两张脑图，我用它们来思考代码和组织代码仓库，至少在我脑海里是这样想的。</p><p>第一张脑图由一系列同心圆层级组成，它们最终按照业务维度的应用模块切分，形成组件。在这张图里，依赖的方向由外向内，意味着内层对外层可见，而外层对内层不可见。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-0d32aa26df941725.png alt=img></p><p>第二张则是一组平面的层级，其中最上面的一层就是前面这张同心圆，下一层是组件之间共享的代码（共享内核），再下一层使是我们自己对编程语言的扩展，最下面一层则是实际使用的编程语言。这里的依赖方向是自上而下的。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-ffe3600b967f7d56.png alt=img></p><h2 id=体现架构的代码风格>体现架构的代码风格</h2><p>使用体现架构的代码风格，意味着代码风格（编码规范、类/方法/变量命名约定、代码结构&mldr;）某种程度上可以和阅读代码的人交流领域和架构的设计意图。要实现体现架构的代码风格，主要有两种思路。</p><blockquote><p>“<em>[…] 体现架构的代码风格能让你给代码的阅读者留下提示，帮助他们正确地推断出设计意图。</em>”
—<em><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fresources.sei.cmu.edu%2Fasset_files%2FPresentation%2F2013_017_001_48651.pdf">George Fairbanks</a></em></p></blockquote><p>第一种思路是通过代码制品的名字（类、变量、模块&mldr;）来传达领域和架构的含义。因此，如果一个类是处理收据（Invoice）实体的仓库（Repository），我们就应该将它命名成<code>InvoiceRepository</code>，从这个名字我们就可以看出，它处理的是收据领域的概念，而它在架构中被当做一个仓库。这可以帮助我们理解它应该放在哪个地方，何时使用它以及如何使用它。但是，我认为代码仓库中并不是每个代码制品都需要这样做，例如，我觉得不必为每个实体（Entity）都加上后缀<code>Entity</code>，这样做就有些画蛇添足，徒增噪音。</p><blockquote><p>“<em>[…] 代码应该体现架构。换句话说，我一看到代码，就应该能够清晰地区分出各种组件[…]</em>”
—<em><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.codingthearchitecture.com%2F2014%2F06%2F01%2Fan_architecturally_evident_coding_style.html">Simon Brown</a></em></p></blockquote><p>第二种思路是让代码仓库中的顶级制品明确地区分出各个子域，即领域维度的模块，也就是组件。</p><p>第一种思路应该很清楚，无需赘述。但第二种思路有点儿微妙，我们得深入探讨一下。</p><h2 id=让架构清晰的展现出来>让架构清晰的展现出来</h2><p>在我的第一张图里，我们已经看到，在最粗粒度的层级上，我们只有三种不同用途的代码：</p><ul><li><strong>用户界面</strong>，这里的代码就是为了适配某个用例的传达机制；</li><li><strong>应用核心</strong>，这里的代码就是用例和领域逻辑；</li><li><strong>基础设施</strong>，这里的代码就是为了适配应用核心所需的工具/库。</li></ul><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-aeb41920cfcbbf7d.png alt=img></p><p>因此，在源代码的根目录下我们可以创建三个文件夹来体现这三类代码，一个文件夹对应一个类别的代码。这三个文件夹表示三个命名空间，稍后我们甚至可以创建测试来断言核心对用户界面和基础设施可见，反过来却不可见，也就是说，我们可以测试由外向内的依赖方向。</p><h3 id=用户界面>用户界面</h3><p>一个 Web 企业应用通常拥有多套 API，例如，一套给客户端使用的 REST API，还有一套给第三方应用使用的 web-hook， 业务还有一套需要维护的遗留 SOAP API，或者还有一套给全新移动应用使用的 GraphQL API…</p><p>这样的应该通常还有一些 CLI 命令，用于定时作业（Cron Job）或按需的维护操作。</p><p>当然，还有普通用户可以使用的网站本身，但也许还有另一个供应用管理员使用的网站。</p><p>这些全都是同一个应用的不同视图，全都是同一个应用的不同用户界面。</p><p>实际上我们的应用可能拥有多个用户界面，其中有些还是供非人类用户（第三方应用）使用的。我们通过文件/命名空间来区分并隔离这些用户界面，来展现出这一点。</p><p>用户界面主要有三类：API、CLI 和网站。所以我们在<strong>UserInterface</strong>根命名空间里为每个类别创建一个文件夹，将不同界面的类型清晰地区分开来。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-624b245d03825b83.png alt=img></p><p>下一步，如果有必要的话，我们还可以继续深入每种类型的命名空间，再创建更细分类的用户界面的命名空间（CLI 可能不需要再细分了）。</p><h3 id=基础设施>基础设施</h3><p>和用户界面一样，我们的应用使用了多种工具（库和第三方应用），例如 ORM、消息队列、SMS 提供商。</p><p>此外，上述每一种工具都可以有不同的实现。例如，考虑一家公司业务扩张到另一个国家的情况，由于价格的因素，不同的国家最好采用不同的 SMS 提供商：我们需要端口相同的适配器的不同实现，这样使用时可以互相替换。另一个例子是对数据库 Schema 进行重构或者切换数据库引擎，需要（或决定要）切换 ORM 时：我们会在应用中注入两种 ORM 适配器。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-8ccf5f3b45771507.png alt=img></p><p>因此，在<strong>Infrastructure</strong>命名空间来说，我们先给每一种工具类型创建一个命名空间（ORM、MessageQueue、SmsClient），然后再每一种工具类型内部为每一种用到的供应商（Doctrine、Propel、MessageBird、Twilio&mldr;）的适配器在创建一个命名空间。</p><h3 id=核心>核心</h3><p>在<strong>Core</strong>命名空间下，可以按照最粗粒度的层级划分出三类代码： <strong>组件（Component）</strong>、<strong>共享内核（Shared Kernel）</strong> 和 <strong>端口（Port）</strong>。为这三个类别创建文件夹/命名空间。</p><h4 id=组件>组件</h4><p>在 <strong>Component</strong> 命名空间下，我们为每个组件创一个命名空间，然后在每个组件命名空间下，我们再分别为应用（Application）层和领域（Domain）层分别创建一个命名空间。 在 <strong>Application</strong> 和 <strong>Domain</strong> 命名空间下，我们先将全部类放在一起，随着类的数量不断增加，再来考虑必要的分组（我觉得一个文件夹下就放一个类有些矫枉过正，所以我宁愿在必要时再进行分组）。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-56031e6011e671a2.png alt=img></p><p>这是我们就要考虑是按照业务主题（收据、交易&mldr;）分组还是按照技术作用（仓库、服务、值对象&mldr;）分组，但我觉得无论怎样分组影响都不大，因为这已经是整个代码组织树的叶子节点了，如果需要，在整个组织结构的最底端进行调整也很简单，不会影响代码仓库的其它部分。</p><h4 id=端口>端口</h4><p>和 <strong>Infrastructure</strong> 命名空间一样，<strong>Port</strong> 命名空间里核心使用的每一种工具都有一个命名空间，核心通过这些代码才能使用底层的这些工具。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-fa908916c589a961.png alt=img></p><p>这些代码还会被适配器使用，它们的作用就是端口和真正工具之间的转换。这种形式简单得不能再简单了，端口就是一个接口，但很多时候它还需要值对象、DTO、服务、构建起、查询对象甚至是仓库。</p><h4 id=共享内核>共享内核</h4><p>我们把在组件之间共享的代码放到 <strong>Shared Kernel</strong> 命名空间下。尝试了几种不同的共享内核内部结构之后，我无法找到一种适用于所有情况的结构。有些代码和<code>Core\Component</code>一样按组件划分很合理（例如 Entity ID 显然属于一个组件），有些代码这样划分却不合适（例如，事件可能被多个组件触发或监听）。也许要结合使用两种划分的思路。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-45ad6553ddaf7f0c.png alt=img></p><h3 id=用户区里的编程语言扩展>用户区里的编程语言扩展</h3><p>最后，我们还有一些自己对编程语言的扩展。这个系列中前面一篇文章已经讨论过，这些代码本可以放在编程语言中，却因为某些原因没有。比如，在 PHP 中我们可以想到的是 DateTime 类，它基于 PHP 提供的类扩展，提供了一些额外的方法。另一个例子是 UUID 类，尽管 PHP 没有提供，但是这个类天然就是纯粹的、对领域无感，因此可以在任意项目中使用，并且不依赖任何领域。</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-bf53ab9eaa2f7e7f.png alt=img></p><p>这些代码用起来和编程语言自己的提供的功能没啥区别，因此我们要完全掌控这些代码。然而，这并不是意味着我们不能使用第三方库。我们能用而且应该用，只要合理，但是这些库应该用我们自己的实现包装起来（这样的话我们可以方便的切换背后的第三方库），而应用代码应该直接使用这些包装代码。最终，这些代码可以自成项目，使用自己的 CVS 仓库，被多个项目使用。</p><h2 id=强化架构>强化架构</h2><p>上述就是所有我们决定要落地的思路和方法，这需要大量投入，也不容易掌握。就算我们掌握了所有思路和方法，但我们终究还是人类，所以我们一定会犯错，我们的同事也会犯错，事情就是这样。</p><p>就像我们为了避免写代码时犯的错进入生产环境而编写测试一样，我们也必须对代码仓库的结构做点什么。</p><p>在 PHP 的世界里，我们有一个叫做 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsensiolabs-de%2Fdeptrac">Deptrac</a> 的小工具可以做这种检查（但我敢打保票其它编程语言也有类似的工具），这个小工具由 Sensiolabs 创建。我们可以通过一个 yaml 文件进行配置，我们可以在其中配置有哪些层级，以及层级之间有哪些依赖。然后我们使用命令行执行测试，这意味着测试可以轻松地在 CI 中执行，就像我们可以在 CI 种执行其它测试一样。（译注，对于 Java 语言来说，也有类似的工具 <a href>https://www.archunit.org/</a>，可以用它把依赖关系的规则写成自动化测试，但是不能生成依赖图。）。</p><p>我们还可以创建依赖图，将依赖可视化地展示出来，包括那些违反实现配置好的规则集的依赖关系：</p><p><img src=19-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8403.assets/4099-721716628932ab38.png alt=img></p><h2 id=总结>总结</h2><p>应用遵循某种领域结构组成，也遵循某种技术结构（即架构）组成。这两种结构才是一个应用的与众不同之处，而不是它使用的工具、库或者传达机制。如果我们想让一个应用可以长时间的维护，这两种结构都要清晰的体现在代码仓库中，这样开发者才能知道、理解、遵循，并在需要时改进。</p><p>这种清晰度让我们可以在编码的同时理解边界，这能反过来帮助我们保持应用的模块化设计，做到高内聚低耦合。</p><p>再一次重申，之前文章里提到的这些思路和实践大多来自于远比我优秀和经验丰富的开发者。我和我在不同公司的同事们进行过反复讨论，也在企业应用代码中进行过尝试，在我参与过的项目中都能得到很好地应用。</p><p>但是，我坚信没有<em>银弹</em>，没有<em>均码的鞋子</em>，没有<em>圣杯</em>。</p><p>本文介绍的思路和解耦可以被视为适用于大多是企业应用的通用模板，如过有必要，不要犹豫，对其进行调整。我们总是要对上下文进行评估并竭尽所能，但我希望并相信这个模板是一个不错的开始，至少值得一试。</p><p>如果你想看看实现了这个模板的 Demo 项目，我 fork 了 Symfony Demo 应用并按照上面的思路进行了重构。你可以在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhgraca%2Fexplicit-architecture-php">这里</a>找到我的重构。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>p3p3pp3</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-05-16</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/2021/software-architecture/7-1-model1-model2.html><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">7.1.Model1&Model2</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/2021/software-architecture/18-%E6%B8%85%E6%99%B0%E6%9E%B6%E6%9E%8402.html><span class="next-text nav-default">18.清晰架构02-超越同心圆分层</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=lv-container data-id=city data-uid="MTAyMC80MjYyNC8xOTE3MQ=="><script type=text/javascript>(function(b,c){var a,d=b.getElementsByTagName(c)[0];if(typeof LivereTower=='function')return;a=b.createElement(c),a.src='https://cdn-city.livere.com/js/embed.dist.js',a.async=!0,d.parentNode.insertBefore(a,d)})(document,'script')</script><noscript>Please enable JavaScript to view the comments powered by <a href=https://livere.com/>LiveRe.</a></noscript></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:p3@live.cn class="iconfont icon-email" title=email></a><a href=http://localhost:1313 class="iconfont icon-stack-overflow" title=stack-overflow></a><a href=http://localhost:1313 class="iconfont icon-twitter" title=twitter></a><a href=http://localhost:1313 class="iconfont icon-facebook" title=facebook></a><a href=http://localhost:1313 class="iconfont icon-linkedin" title=linkedin></a><a href=http://localhost:1313 class="iconfont icon-google" title=google></a><a href=http://localhost:1313 class="iconfont icon-github" title=github></a><a href=http://localhost:1313 class="iconfont icon-weibo" title=weibo></a><a href=http://localhost:1313 class="iconfont icon-zhihu" title=zhihu></a><a href=http://localhost:1313 class="iconfont icon-douban" title=douban></a><a href=http://localhost:1313 class="iconfont icon-pocket" title=pocket></a><a href=http://localhost:1313 class="iconfont icon-tumblr" title=tumblr></a><a href=http://localhost:1313 class="iconfont icon-instagram" title=instagram></a><a href=http://localhost:1313 class="iconfont icon-gitlab" title=gitlab></a><a href=http://localhost:1313 class="iconfont icon-bilibili" title=bilibili></a><a href=https://p3p3pp3.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>p3p3pp3</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-134997356-1','auto'),ga('set','anonymizeIp',!0),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script id=baidu_push>(function(){var a,c,b;if(window.location.hostname==='localhost')return;a=document.createElement('script'),a.async=!0,c=window.location.protocol.split(':')[0],c==='https'?a.src='https://zz.bdstatic.com/linksubmit/push.js':a.src='http://push.zhanzhang.baidu.com/push.js',b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script></body></html>